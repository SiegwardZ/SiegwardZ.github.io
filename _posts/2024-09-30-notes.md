---
layout: post
title: Notes
categories: [Technology,Notes]
tags: [technology]
description: A technical notes for recording encountered issues and techniques.
comments: false
math: true
---
### Cross-Attention
```python
if is_cross_attention:
    key_layer = self.transpose_for_scores(self.key(encoder_hidden_states))
    value_layer = self.transpose_for_scores(self.value(encoder_hidden_states))
    attention_mask = encoder_attention_mask
elif past_key_value is not None:
    key_layer = self.transpose_for_scores(self.key(hidden_states))
    value_layer = self.transpose_for_scores(self.value(hidden_states))
    key_layer = torch.cat([past_key_value[0], key_layer], dim=2)
    value_layer = torch.cat([past_key_value[1], value_layer], dim=2)
else:
    key_layer = self.transpose_for_scores(self.key(hidden_states))
    value_layer = self.transpose_for_scores(self.value(hidden_states))
```
如果是cross attention的话，在decoder层传入的encoder_hidden_states参数是用来在cross attention中做为key和value的。query仍为input_ids。

## Pytorch 
### gradient 计算
如果已知梯度公式但没法表示原函数，有如下几种方法计算梯度：
1. 根据梯度反推出另一个原函数，用那个原函数作为loss function计算梯度，常见操作如将 $ \nabla f(x) $ 替换成 $ f(x) \nabla log f(x) $
2. 根据梯度公式，通过冻结部分参数的方式实现梯度计算，即把不需要计算梯度的部分当作常数，将它们放在no_grad下计算

### 查看module的gradient
查看module参数的梯度:
```python
for name, param in model.named_parameters():
    if param.grad is not None:
        print(f"grad of param {name}: \n {param.grad}")
    else:
        print(f"param {name} has no grad")
```
### 两次调用loss backward后报错 计算图不能使用两次
看看是不是调用`optimizer.zero_grad()`后复用了前一个loss的计算图
每次清空梯度后需要从头开始计算下一个loss



## Markdown 
### 并排显示表格
1. html

```html
<p align="center">
    <img src="" alt="Image 1" width="45%" />
    <img src="" alt="Image 2" width="45%" />
</p>
```

2. table
```markdown
| ![Image 1](image1.png) | ![Image 2](image2.png) |
|------------------------|------------------------|
```

### 展示html代码块
注意\`\`\`前如果是html，需要空一行

## Python
### 调用摄像头
```python
import numpy as np
import cv2

cap = cv2.VideoCapture(0)
w = int(cap.get(3))  # 获取视频的width
h = int(cap.get(4))  # 获取视频的height
fourcc = cv2.VideoWriter_fourcc(*'XVID')
out = cv2.VideoWriter('output.avi',fourcc, 30.0, (w, h))

while(cap.isOpened()):
    ret, frame = cap.read()
    if ret==True:
        frame = cv2.flip(frame,1)
        out.write(frame) # 保存视频
        cv2.imshow('frame', frame)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    else:
        break

cap.release()
out.release()
cv2.destroyAllWindows()
```
ref:[https://blog.csdn.net/qq_45779334/article/details/114676905](https://blog.csdn.net/qq_45779334/article/details/114676905)

## Linux
### Shell同时输出到文件和控制台
```bash
<your program> | tee <your file path>
```
### 查看tcp端口占用
```bash
lsof -wni tcp:4000
```
